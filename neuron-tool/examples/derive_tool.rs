//! Example: `#[neuron_tool]` macro with multiple tools and custom types.
//!
//! Shows defining tools with the derive macro, custom output/error types,
//! and both registry-based and direct typed calls.
//!
//! Run with: `cargo run --example derive_tool -p neuron-tool`

use neuron_tool::{neuron_tool, ToolRegistry};
use neuron_types::{Tool, ToolContext};

// --- Custom output type ---

#[derive(Debug, serde::Serialize)]
struct FileInfo {
    path: String,
    exists: bool,
    size_bytes: Option<u64>,
}

#[derive(Debug, thiserror::Error)]
enum FileError {
    #[error("path is empty")]
    EmptyPath,
}

// --- Tool 1: check if a file exists ---

#[neuron_tool(name = "check_file", description = "Check if a file exists and return its size")]
async fn check_file(
    /// The file path to check
    path: String,
    _ctx: &ToolContext,
) -> Result<FileInfo, FileError> {
    if path.is_empty() {
        return Err(FileError::EmptyPath);
    }
    let metadata = std::fs::metadata(&path).ok();
    Ok(FileInfo {
        path: path.clone(),
        exists: metadata.is_some(),
        size_bytes: metadata.map(|m| m.len()),
    })
}

// --- Tool 2: simple string tool ---

#[neuron_tool(name = "greet", description = "Generate a greeting for a person")]
async fn greet(
    /// The person's name
    name: String,
    /// Whether to be formal
    formal: bool,
    _ctx: &ToolContext,
) -> Result<String, std::convert::Infallible> {
    if formal {
        Ok(format!("Good day, {name}. How may I assist you?"))
    } else {
        Ok(format!("Hey {name}!"))
    }
}

#[tokio::main]
async fn main() {
    // Register both tools
    let mut registry = ToolRegistry::new();
    registry.register(CheckFileTool);
    registry.register(GreetTool);

    // Show tool definitions (JSON Schema is auto-generated by schemars)
    println!("Registered tools:");
    for def in registry.definitions() {
        println!("  {} — {}", def.name, def.description);
    }

    // Execute via registry
    let ctx = ToolContext::default();

    let result = registry
        .execute("greet", serde_json::json!({"name": "Alice", "formal": true}), &ctx)
        .await
        .unwrap();
    println!("\nGreet output: {:?}", result.content);

    let result = registry
        .execute("check_file", serde_json::json!({"path": "/tmp"}), &ctx)
        .await
        .unwrap();
    println!("CheckFile output: {:?}", result.structured_content);

    // Direct typed call (compile-time checked)
    let info = CheckFileTool
        .call(CheckFileArgs { path: "Cargo.toml".into() }, &ctx)
        .await
        .unwrap();
    println!("\nDirect call — Cargo.toml exists: {}, size: {:?}", info.exists, info.size_bytes);
}
